<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Metadata -->
    <title>Everline Forest - Procedural Art Engine</title>
    <meta name="description" content="Everline Forest, an immersive procedural art engine. Explore an infinite, atmospheric generative landscape with customizable recursive depth, snowfall density, and shifting color palettes. Built for high-performance visual relaxation.">
    <meta name="keywords" content="everline forest, procedural art, generative art, creative coding, javascript canvas, atmospheric art, digital installation, webgl alternative">
    <link rel="canonical" href="https://pirillo.com/arcade/everline-forest.html">
    <meta name="author" content="Chris Pirillo">
    <meta name="robots" content="index, follow">

    <!-- Social Metadata (Open Graph) -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/everline-forest.html">
    <meta property="og:title" content="Everline Forest - Procedural Art Engine">
    <meta property="og:description" content="An infinite atmospheric forest engine featuring procedurally generated geometry and snowfall. Customize your aesthetic experience in real-time.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/everline-forest.png">

    <!-- Twitter Card Metadata -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Everline Forest - Procedural Art Engine">
    <meta name="twitter:description" content="Dive into a procedurally generated forest with shifting colors and snowfall. A generative art experiment by Chris Pirillo.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/everline-forest.png">

    <!-- Resource Hints -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VisualArtwork",
      "name": "Everline Forest",
      "alternateName": "Everline Forest Generative Engine",
      "description": "A high-performance procedurally generated art installation featuring recursive geometric trees and atmospheric snowfall.",
      "creator": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com",
        "sameAs": "https://x.com/ChrisPirillo"
      },
      "image": "https://pirillo.com/arcade/images/everline-forest.png",
      "url": "https://pirillo.com/arcade/everline-forest.html",
      "artMedium": "Procedural Code",
      "artform": "Generative Art"
    }
    </script>

    <!-- Google Tag Manager -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        canvas {
            display: block;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* Glassmorphism Menu */
        #menu {
            position: fixed;
            top: 0;
            right: -350px;
            width: 320px;
            height: 100%;
            background: rgba(10, 10, 15, 0.92);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            transition: right 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 100;
            padding: 2rem 1.5rem;
            overflow-y: auto;
            color: white;
            box-shadow: -15px 0 35px rgba(0, 0, 0, 0.8);
        }

        #menu.open {
            right: 0;
        }

        .hamburger {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 110;
            cursor: pointer;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s;
        }

        .hamburger:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        .control-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.4);
        }

        input[type="range"] {
            width: 100%;
            accent-color: #60a5fa;
            cursor: pointer;
        }

        .btn {
            width: 100%;
            padding: 0.85rem;
            border-radius: 8px;
            margin-bottom: 0.6rem;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
            cursor: pointer;
            text-align: center;
            border: none;
        }

        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; transform: translateY(-1px); }
        .btn-secondary { background: rgba(255, 255, 255, 0.08); color: white; border: 1px solid rgba(255, 255, 255, 0.1); }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.15); }

        .checkbox-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.5s ease;
        }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }
        
        /* Visually Hidden for SEO H1 */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>

    <h1 class="sr-only">Everline Forest: A Procedural Generative Art Experience by Chris Pirillo</h1>

    <div id="fade-overlay"></div>

    <header>
        <button class="hamburger" id="menu-toggle" aria-label="Toggle Engine Controls" aria-expanded="false" aria-controls="menu">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
    </header>

    <aside id="menu" role="complementary">
        <h2 class="text-xl font-bold mb-6 tracking-tight border-b border-white/10 pb-4">Engine Controls</h2>
        
        <div class="control-group">
            <label for="j_start">Recursive Depth (j)</label>
            <input type="range" id="j_start" min="10" max="80" value="40">
        </div>

        <div class="control-group">
            <label for="height_scale">Vertical Boost (Limit 1.5)</label>
            <input type="range" id="height_scale" min="0.5" max="1.5" step="0.05" value="1.1">
        </div>

        <div class="control-group">
            <label for="size_variance">Structural Variance</label>
            <input type="range" id="size_variance" min="0" max="1.5" step="0.05" value="0.75">
        </div>

        <div class="control-group">
            <label for="flake_density">Snowflake Density</label>
            <input type="range" id="flake_density" min="1" max="10" step="1" value="8">
        </div>

        <div class="control-group">
            <label for="T_val">Forest Density (T)</label>
            <input type="range" id="T_val" min="50" max="400" value="180">
        </div>

        <div class="control-group">
            <label for="speed">Drift Speed</label>
            <input type="range" id="speed" min="0" max="0.5" step="0.005" value="0.12">
            <div class="checkbox-row mt-1">
                <label for="lock_speed" class="mb-0 text-[10px]">Lock Speed on Random</label>
                <input type="checkbox" id="lock_speed" class="w-4 h-4 cursor-pointer">
            </div>
        </div>

        <div class="control-group">
            <label for="depth_fade">Depth Fade (Atmosphere)</label>
            <input type="range" id="depth_fade" min="0.1" max="2.0" step="0.05" value="0.4">
        </div>

        <div class="control-group">
            <label for="direction">Drift Direction</label>
            <select id="direction" class="w-full bg-white/5 border border-white/10 rounded p-2 text-sm focus:outline-none">
                <option value="1" class="bg-slate-900">Left</option>
                <option value="-1" class="bg-slate-900">Right</option>
            </select>
        </div>

        <div class="control-group">
            <label for="scale_val">Vertical Scale Stack</label>
            <input type="range" id="scale_val" min="1.0" max="1.05" step="0.001" value="1.02">
        </div>

        <div class="control-group">
            <label for="fill_color">Primary Hue</label>
            <input type="color" id="fill_color" class="w-full h-8 bg-transparent border-none cursor-pointer" value="#3b82f6">
        </div>

        <div class="control-group">
            <label for="snowflake_color">Snowflake Color</label>
            <input type="color" id="snowflake_color" class="w-full h-8 bg-transparent border-none cursor-pointer" value="#ffffff">
        </div>

        <div class="control-group">
            <div class="checkbox-row">
                <label for="auto_advance" class="mb-0">Auto-Advance</label>
                <input type="checkbox" id="auto_advance" class="w-5 h-5 cursor-pointer">
            </div>
        </div>

        <div class="control-group">
            <div class="flex justify-between items-baseline mb-2">
                <label for="advance_interval" class="mb-0">Delay</label>
                <span id="delay_display" class="text-xs text-white/60 font-mono">12s</span>
            </div>
            <input type="range" id="advance_interval" min="3" max="60" value="12">
        </div>

        <div class="pt-6 space-y-2 border-t border-white/10">
            <button class="btn btn-primary" id="btn-random">Randomize Scene</button>
            <button class="btn btn-secondary" id="btn-reset">Reset Defaults</button>
            <button class="btn btn-secondary" id="btn-4k">Export 4K Image</button>
        </div>
    </aside>

    <main>
        <canvas id="c"></canvas>
    </main>

    <script>
        (function() {
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            const S = Math.sin;
            const C = Math.cos;

            const overlay = document.getElementById('fade-overlay');
            const menu = document.getElementById('menu');
            const menuToggle = document.getElementById('menu-toggle');
            const delayDisplay = document.getElementById('delay_display');

            let t = 0;
            let isMenuOpen = false;
            let lastAdvance = 0;
            let isTransitioning = false; // Flag to prevent multi-firing

            const config = {
                j_start: 40,
                T_val: 180,
                scale_val: 1.02,
                size_variance: 0.75,
                flake_density: 8,
                height_scale: 1.1,
                X_mod: 2500,
                Y_max: 460, 
                speed: 0.12,
                lock_speed: false,
                direction: 1,
                fill_color: '#3b82f6',
                snowflake_color: '#ffffff',
                auto_advance: false,
                advance_interval: 12,
                hue_variation: 2.5,
                depth_fade: 0.4,
                fill_h_coeff: 4,
                fill_h_pow: 0.55,
                sin_mult: 9,
                t_mult: 99
            };

            const defaults = { ...config };

            function init() {
                resize();
                randomize(true);
                loop(0);
                updateDelayDisplay();
            }

            function resize() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }

            function randomize(instant = false) {
                // If a transition is already happening, ignore new requests (fixes rapid fire bug)
                if (isTransitioning) return;

                if (!instant) {
                    isTransitioning = true;
                    overlay.style.opacity = '1';
                    
                    // Wait for fade to black
                    setTimeout(() => {
                        applyRandomParams();
                        overlay.style.opacity = '0';
                        
                        // Wait for fade in to complete before allowing another transition
                        setTimeout(() => {
                            isTransitioning = false;
                        }, 500);
                    }, 500);
                } else {
                    applyRandomParams();
                }
            }

            function rgbToHsl(hex) {
                let r = parseInt(hex.slice(1, 3), 16) / 255;
                let g = parseInt(hex.slice(3, 5), 16) / 255;
                let b = parseInt(hex.slice(5, 7), 16) / 255;
                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max == min) h = s = 0;
                else {
                    let d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            function hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            function applyRandomParams() {
                config.j_start = 30 + Math.random() * 30;
                config.T_val = 150 + Math.random() * 150; 
                config.scale_val = 1.01 + Math.random() * 0.02;
                config.size_variance = 0.3 + Math.random() * 0.8;
                config.height_scale = 0.8 + Math.random() * 0.5; 
                config.depth_fade = 0.2 + Math.random() * 0.4;
                config.flake_density = 6 + Math.floor(Math.random() * 4); 
                
                if (!config.lock_speed) {
                    config.speed = 0.05 + Math.random() * 0.15;
                }
                
                const mainHue = Math.floor(Math.random() * 360);
                config.fill_color = hslToHex(mainHue, 45 + Math.random() * 30, 35 + Math.random() * 25);
                config.snowflake_color = '#ffffff';

                updateUI();
                // Reset the timer whenever parameters change
                lastAdvance = performance.now();
            }

            function updateUI() {
                document.getElementById('j_start').value = config.j_start;
                document.getElementById('T_val').value = config.T_val;
                document.getElementById('scale_val').value = config.scale_val;
                document.getElementById('size_variance').value = config.size_variance;
                document.getElementById('height_scale').value = config.height_scale;
                document.getElementById('flake_density').value = config.flake_density;
                document.getElementById('fill_color').value = config.fill_color;
                document.getElementById('snowflake_color').value = config.snowflake_color;
                document.getElementById('auto_advance').checked = config.auto_advance;
                document.getElementById('lock_speed').checked = config.lock_speed;
                document.getElementById('direction').value = config.direction;
                document.getElementById('advance_interval').value = config.advance_interval;
                document.getElementById('speed').value = config.speed;
                document.getElementById('depth_fade').value = config.depth_fade;
                updateDelayDisplay();
            }

            function updateDelayDisplay() {
                delayDisplay.innerText = config.advance_interval + 's';
            }

            function noise(v) {
                const x = Math.sin(v) * 10000;
                return x - Math.floor(x);
            }

            function loop(timestamp) {
                t += 0.01 * config.speed;

                render(ctx, canvas.width, canvas.height, t);

                if (config.auto_advance && !isTransitioning) {
                    // Check if enough time has passed
                    if (timestamp - lastAdvance > config.advance_interval * 1000) {
                        randomize();
                    }
                }

                requestAnimationFrame(loop);
            }

            function render(rCtx, width, height, time) {
                rCtx.save();
                rCtx.fillStyle = '#000';
                rCtx.fillRect(0, 0, width, height);
                
                const verticalScale = height / config.Y_max;
                
                // ANCHOR TO BOTTOM CENTER
                rCtx.translate(width / 2, height);
                rCtx.scale(verticalScale, verticalScale);
                
                // Translate logical coords so (X_mod/2, Y_max) is our anchor point
                rCtx.translate(-config.X_mod / 2, -config.Y_max);

                let T = config.T_val;
                let j_start = Math.floor(config.j_start);
                let baseHsl = rgbToHsl(config.fill_color);

                const flakeDivisor = Math.max(1, Math.floor(12 - config.flake_density));

                for(let j = j_start; j--;) {
                    // Internal scaling now pivots from the anchored bottom center
                    rCtx.scale(config.scale_val, config.scale_val);
                    
                    let h_val = (T + Math.pow(j, 6) % T) * config.height_scale;
                    let i = h_val;
                    
                    let iterFactor = j / j_start; 
                    let lumFactor = Math.pow(1 - iterFactor, config.depth_fade); 
                    satFactor = 1 - iterFactor * 0.5;
                    let currentHue = (baseHsl.h + (j * 2)) % 360;
                    
                    rCtx.fillStyle = `hsl(${currentHue}, ${baseHsl.s * satFactor}%, ${baseHsl.l * lumFactor}%)`;
                    
                    while(i > 0) {
                        const seed = (j * 13) + (i * 7);
                        const n1 = noise(seed);
                        
                        const localWidthMult = 0.2 + (n1 * config.size_variance);
                        
                        let w = (i / 5) * localWidthMult; 
                        let y = h_val - i;
                        let X_raw = Math.pow(j, 5) - (time * config.direction) * T;
                        let xPos = ((X_raw % config.X_mod) + config.X_mod) % config.X_mod;
                        
                        let structX = xPos - h_val * y % Math.max(0.1, w) - T;
                        let structY = config.Y_max - y;
                        let structH = (config.fill_h_coeff / Math.pow(j + 1, 0.6));
                        
                        rCtx.fillRect(structX, structY, w, structH);
                        
                        if (Math.floor(i) % flakeDivisor === 0) {
                            let flakeX_raw = (X_raw + i * T);
                            let flakeX = ((flakeX_raw % config.X_mod) + config.X_mod) % config.X_mod + S(time * 3 + i) * 8;
                            let flakeY_raw = (time * 99 + Math.pow(i, 5));
                            let flakeY = (flakeY_raw % config.Y_max);
                            let r = (i % 3) + 1.8;
                            
                            rCtx.save();
                            rCtx.globalAlpha = Math.max(0.3, lumFactor * 0.8);
                            rCtx.fillStyle = config.snowflake_color;
                            rCtx.fillRect(flakeX, flakeY, r, r);
                            rCtx.restore();
                        }
                        
                        i--;
                    }
                }
                
                rCtx.restore();
            }

            function export4K() {
                const offscreen = document.createElement('canvas');
                offscreen.width = 3840;
                offscreen.height = 2160;
                const oCtx = offscreen.getContext('2d');
                render(oCtx, 3840, 2160, t);
                const link = document.createElement('a');
                link.download = `everline_forest_4k.png`;
                link.href = offscreen.toDataURL('image/png');
                link.click();
            }

            window.addEventListener('resize', resize);
            
            canvas.addEventListener('click', () => {
                if (!isMenuOpen) randomize();
            });

            menuToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                isMenuOpen = !isMenuOpen;
                menu.classList.toggle('open', isMenuOpen);
                menuToggle.setAttribute('aria-expanded', isMenuOpen);
            });

            window.addEventListener('click', (e) => {
                if (isMenuOpen && !menu.contains(e.target) && !menuToggle.contains(e.target)) {
                    isMenuOpen = false;
                    menu.classList.remove('open');
                    menuToggle.setAttribute('aria-expanded', false);
                }
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isMenuOpen) {
                    isMenuOpen = false;
                    menu.classList.remove('open');
                    menuToggle.setAttribute('aria-expanded', false);
                }
            });

            // UI Listeners
            document.getElementById('j_start').addEventListener('input', e => config.j_start = parseFloat(e.target.value));
            document.getElementById('T_val').addEventListener('input', e => config.T_val = parseFloat(e.target.value));
            document.getElementById('scale_val').addEventListener('input', e => config.scale_val = parseFloat(e.target.value));
            document.getElementById('size_variance').addEventListener('input', e => config.size_variance = parseFloat(e.target.value));
            document.getElementById('height_scale').addEventListener('input', e => config.height_scale = parseFloat(e.target.value));
            document.getElementById('flake_density').addEventListener('input', e => config.flake_density = parseFloat(e.target.value));
            document.getElementById('fill_color').addEventListener('input', e => config.fill_color = e.target.value);
            document.getElementById('snowflake_color').addEventListener('input', e => config.snowflake_color = e.target.value);
            
            document.getElementById('auto_advance').addEventListener('change', e => {
                config.auto_advance = e.target.checked;
                if (config.auto_advance) {
                    lastAdvance = performance.now();
                }
            });

            document.getElementById('lock_speed').addEventListener('change', e => config.lock_speed = e.target.checked);
            document.getElementById('direction').addEventListener('change', e => config.direction = parseInt(e.target.value));
            
            document.getElementById('advance_interval').addEventListener('input', e => {
                config.advance_interval = parseFloat(e.target.value);
                updateDelayDisplay();
            });

            document.getElementById('speed').addEventListener('input', e => config.speed = parseFloat(e.target.value));
            document.getElementById('depth_fade').addEventListener('input', e => config.depth_fade = parseFloat(e.target.value));

            document.getElementById('btn-random').addEventListener('click', () => randomize());
            document.getElementById('btn-reset').addEventListener('click', () => {
                Object.assign(config, defaults);
                updateUI();
                randomize();
            });
            document.getElementById('btn-4k').addEventListener('click', export4K);

            init();
        })();
    </script>
</body>
</html>